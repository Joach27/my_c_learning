// LES SEGMENTS DE MEMOIRE //

+--------------------+
| Stack              | ‚Üê Haut de la m√©moire (adresses √©lev√©es)
| (variables locales)|
+--------------------+
| Heap               |
| (malloc, new)      |
+--------------------+
| BSS (.bss)         |
| (globals non init) |
+--------------------+
| Data (.data)       |
| (globals init)     |
+--------------------+
| RO Data (.rodata)  |
| (consts, strings)  |
+--------------------+
| Code (.text)       | ‚Üê Bas de la m√©moire (adresses basses)
| (instructions)     |
+--------------------+



// ADRESSE DE RETOUR //
L'adresse de retour indique o√π reprendre apr√®s une fonction

Avant l'appel de foo()
Stack:
+------------------+
| ...              |
+------------------+

Apr√®s `call foo` :
Stack:
+------------------+
| Adresse de retour ‚Üê o√π revenir apr√®s foo
+------------------+
| Ancien RBP       |
+------------------+ 

/// VALEUR RETOURNEE PAR LA FONCTION ET L'ADRESSE DE RETOUR ///
‚úÖ 1. Valeur de retour ‚Üí registre (EAX ou RAX)
Quand une fonction retourne une valeur (ex : un int), le r√©sultat est stock√© dans un registre du processeur :

EAX si le programme est en 32 bits

RAX si le programme est en 64 bits

‚û°Ô∏è La fonction appelante lit simplement ce registre pour r√©cup√©rer la valeur de retour.

‚úÖ 2. Adresse de retour ‚Üí stack
Quand une fonction est appel√©e, le programme doit se souvenir o√π reprendre l‚Äôex√©cution apr√®s la fin de cette fonction.

Cette adresse de retour est pouss√©e (plac√©e) sur la pile avant que la fonction ne commence √† s‚Äôex√©cuter.

‚û°Ô∏è √Ä la fin de la fonction, l'instruction ret lit cette adresse sur la pile et reprend l‚Äôex√©cution √† cet endroit-l√†.


// IMPORTANCE //
S√©curit√© : Des attaques comme le buffer overflow visent √† √©craser l‚Äôadresse de retour pour rediriger le programme vers du code malicieux (ex. shellcode).

Fonctionnement du call stack : Sans l‚Äôadresse de retour, le programme ne saurait jamais o√π revenir apr√®s une fonction.


//////////////// CE QUI SE PASSE QUAND ON FAIT APPEL A UNE FONCTION ///////////////

Les r√©gistres qui son utilis√©s 
-- EBP (Base pointer) : pointer de base qui r√©f√©rencie les variables locales et les param√®tres
-- ESP (Stack pointer) : pointeur de pile qui g√®re l'allocation de la pile (pointe vers le haut de la pile)
-- EIP (Instruction pointer) : pointeur d'instruction qui indique l'instruction en cours d'ex√©cution

1. Chargement des param√®tres dans les registres (ou sur la pile si il y en a trop, de droite √† gauche)
2. Sauvegarde de l'adresse de retour (EIP) sur la pile
3. Sauvegarde de l'ancien EBP (EBP) sur la pile
4. Mise √† jour de EBP avec la valeur de ESP (pointe vers le haut de la pile)
5. Allocation de la pile pour les variables locales


//// ETAPE 3 DE L'APPEL DE FONCTION (FONCTION add) ////

Situation avant l'√âtape 3 (juste apr√®s l'instruction CALL)
Les param√®tres ont √©t√© pouss√©s sur la pile par la fonction appelante (main).
L'instruction CALL add a pouss√© l'adresse de retour (OLD EIP) sur la pile.
EIP pointe maintenant vers la premi√®re instruction de la fonction add.
ESP (Stack Pointer) pointe vers l'adresse de retour (OLD EIP) qui est actuellement au sommet de la pile.
EBP (Base Pointer) pointe toujours vers le bas du cadre de pile de la fonction appelante (main). Il n'a pas encore √©t√© modifi√© par la fonction add.

        Adresse M√©moire Inf√©rieure
        ^
        |
        +-----------------+
        | ... (espace vide) ...    |
        +-----------------+ <-- ESP pointe ici (vers OLD EIP)
        | Adresse Retour (OLD EIP) |
        +-----------------+        |
        | Param√®tre 1 (10)         |
        +-----------------+        |
        | Param√®tre 2 (20)         |
        +-----------------+
        | ... cadre de pile de main ...  | <-- EBP (de main) pointe quelque part ici
        v
        Adresse M√©moire Sup√©rieure


/// VIRTUAL MEMORY ///
L'espace d'adressage virtuel est une abstraction faite par le syst√®me pour faire croire √† un processus qu'il a toute la m√©moire pour lui seul, alors qu'en r√©alit√© elle est partag√©e entre tous les processus

0xFFFFFFFF  ‚Üê Adresse la plus haute
   |
   |  Kernel Stack     ‚Üê Inaccessible au processus utilisateur
   |
0x7FFFFFFF  ‚Üê Limite entre l‚Äôespace utilisateur et l‚Äôespace noyau
   |
   |  Stack            ‚Üê Cro√Æt vers le bas
   |
   |  Data + Heap      ‚Üê Variables globales, malloc
   |
   |  Text             ‚Üê Contient le code machine du programme
   |
0x00000000  ‚Üê Adresse la plus basse

| Concept                | Description                                                     |
| ---------------------- | --------------------------------------------------------------- |
| **Espace virtuel**     | Vue isol√©e que chaque processus a de la m√©moire.                |
| **Isolation**          | Les processus ne peuvent pas acc√©der √† la m√©moire des autres.   |
| **Partie utilisateur** | De `0x00000000` √† `0x7FFFFFFF` (code, donn√©es, heap, stack).    |
| **Partie noyau**       | De `0x80000000` √† `0xFFFFFFFF` ‚Äì prot√©g√©e, r√©serv√©e au syst√®me. |
| **Avantage**           | S√©curit√©, stabilit√©, simplicit√© de programmation.               |


//////////////TRADUCTION D'UNE ADRESSE VIRTUAL EN ADRESSE MEMOIRE////////////


## üß† **D√©finition rapide**

* **Adresse virtuelle (VA)** : Adresse utilis√©e par un programme (processus) pour acc√©der √† la m√©moire.
* **Adresse physique (PA)** : Adresse r√©elle en m√©moire vive (RAM).

Un programme ne voit jamais les vraies adresses physiques : le syst√®me d‚Äôexploitation (OS) et le **MMU** (Memory Management Unit) traduisent les adresses virtuelles en adresses physiques **√† la vol√©e**.

---

## üß± **Les √©tapes de la traduction VA ‚Üí PA**

### 1. **Segmentation (parfois utilis√©e dans les vieux syst√®mes)**

* L'adresse virtuelle est divis√©e en **segment + offset**.
* Le syst√®me regarde dans une **table des segments** pour savoir o√π commence ce segment en m√©moire physique.

Mais de nos jours, la **pagination** est plus courante. üëá

---

### 2. ‚úÖ **Pagination (m√©thode moderne la plus utilis√©e)**

1. **L'espace virtuel** est d√©coup√© en **pages** (souvent 4 Ko).
2. **La RAM physique** est divis√©e en **cadres (frames)** de m√™me taille.
3. L‚ÄôOS maintient une **table des pages** (Page Table), par processus.

### üîÑ Traduction d‚Äôadresse :

* Une **adresse virtuelle** est divis√©e en :

  * `Page Number` (index dans la page table)
  * `Offset` (d√©placement √† l‚Äôint√©rieur de la page)

* Le **MMU** (un circuit mat√©riel) fait :

  ```text
  VA = Page Number + Offset
      ‚Üì (traduction avec la Page Table)
  PA = Frame Number (physique) + Offset
  ```

---

### üì¶ Exemple :

Supposons une adresse virtuelle `0x00002ABC` :

* Taille des pages : 4 Ko (4096 octets)
  ‚Üí donc 12 bits pour l‚Äôoffset, le reste pour le num√©ro de page.

* **Page Number** : bits[31:12] ‚Üí `0x00002`

* **Offset** : bits[11:0] ‚Üí `0xABC`

La page `0x00002` est mapp√©e (dans la page table) au **cadre physique** `0x0015`.

‚û°Ô∏è **Adresse physique =** `0x0015ABC`

---

### üîê Bonus : la protection m√©moire

* Chaque processus a sa **propre table des pages**.
* Cela emp√™che un processus d‚Äôacc√©der √† la m√©moire d‚Äôun autre ‚Üí **isolation et s√©curit√©**.

---

## üß† R√©sum√© en une phrase :

> L'adresse virtuelle utilis√©e par un programme est traduite dynamiquement par le **MMU**, en consultant la **page table**, pour obtenir l'adresse physique r√©elle en RAM.

//// PAGE TABLE ////

L‚Äôadresse virtuelle est divis√©e en :
        Num√©ro de page (Virtual Page) ‚Üí sert d‚Äôindex
        Offset ‚Üí position √† l‚Äôint√©rieur de la page

Le num√©ro de page permet d‚Äôacc√©der √† la table des pages.

La table des pages contient : 
    ->La Page Table contient une entr√©e pour chaque num√©ro de page virtuelle possible.

        Un bit VALID (pr√©sente ou non en m√©moire)
        L‚Äôadresse de la page physique (si valide)
        Sinon, l‚Äôadresse sur le disque de swap

Si la page est valide, on combine :
        L‚Äôadresse de la page physique
                le offset
                        ‚Üí pour obtenir l‚Äôadresse physique finale.


Adresse virtuelle :   [ Page number | Offset ]
                            |
                            V
                     Page Table Lookup
                            |
                +-----------+-----------+
                | VALID = 1 | Frame #42 |
                +-----------+-----------+
                            |
                    Physical Frame #42
                            + Offset
                            |
                            V
                  Adresse physique finale
